<html lang="en">

</html>

<head>
    <meta charset="UTF-8">
    <title>Couple Sleeping Habits</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
</head>
<style>
    .state {
        fill: #b07264;
    }

    .outline {
        fill: none;
        stroke: rgb(146, 140, 140);
        stroke-width: 1px;
    }

    .graticule {
        fill: none;
        stroke: grey;
        stroke-width: 1px;
    }

    #details {
        position: absolute;
        right: 5%;
        width: 250px;
        padding: 10px;
        background-color: #ffffff69;
        border: 1px solid #ccc;
        border-radius: 15px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    button {
        width: 150px;
        margin-bottom: 5px;
        cursor: pointer;
    }

    #sentimentButtonAll {
        background: #97A29D;
        border: none;
        border-radius: 8px;
    }

    #sentimentButton1 {
        background: #958C6F;
        border: none;
        border-radius: 8px;
    }

    #sentimentButton2 {
        background: #894435;
        border: none;
        border-radius: 8px;
    }

    #sentimentButton3 {
        background: #E1886A;
        border: none;
        border-radius: 8px;
    }
    body {
     
    margin: 0; 
    padding: 0;
    background-image: url('Background Design for Visualized Article.png'); 
    background-position: center center; /* Center the background image */
    background-repeat: no-repeat; /* Do not repeat the image */
    background-attachment: scroll; /* Optional: fixes the background */
    background-size: cover; /* Cover the entire viewport */
    height: 741px; /* Minimum height of viewport */
    width: 1104px; /* Minimum width of viewport */
}
    
</style>

<body style="display: flex; flex-direction: column;">
    <div style="display: flex;height: 100%; align-items: center;justify-content: center;">
        <div style="display: flex; flex-direction:column; height: 100%; ">
            <svg id="text1" width="450" style="background: transparent;">
                <div>some text</div>
            </svg>
        </div>
        <div>
            <svg id="mapTitle" height="50" width="900"></svg>
            <svg id="map" height="500" width="900" style="background: transparent">
                <defs>
                    <pattern id="image1" patternContentUnits="objectBoundingBox" width="1" height="1">
                        <image id="image1Element" href="./less_1_years.svg" x="0" y="0" width="1" height="1"
                            preserveAspectRatio="xMidYMid slice" />
                    </pattern>
                    <pattern id="image2" patternContentUnits="objectBoundingBox" width="1" height="1">
                        <image id="image2Element" href="./1_5_years.svg" x="0" y="0" width="1" height="1"
                            preserveAspectRatio="xMidYMid slice" />
                    </pattern>
                    <pattern id="image3" patternContentUnits="objectBoundingBox" width="1" height="1">
                        <image id="image3Element" href="./6_10_years.svg" x="0" y="0" width="1" height="1"
                            preserveAspectRatio="xMidYMid slice" />
                    </pattern>
                    <pattern id="image4" patternContentUnits="objectBoundingBox" width="1" height="1">
                        <image id="image4Element" href="./11_15_years.svg" x="0" y="0" width="1" height="1"
                            preserveAspectRatio="xMidYMid slice" />
                    </pattern>
                    <pattern id="image5" patternContentUnits="objectBoundingBox" width="1" height="1">
                        <image id="image5Element" href="./16_20_years.svg" x="0" y="0" width="1" height="1"
                            preserveAspectRatio="xMidYMid slice" />
                    </pattern>
                    <pattern id="image6" patternContentUnits="objectBoundingBox" width="1" height="1">
                        <image id="image6Element" href="./20_more_years.svg" x="0" y="0" width="1" height="1"
                            preserveAspectRatio="xMidYMid slice" />
                    </pattern>
                </defs>
            </svg>
            <svg id="mapLegend" height="180" width="900"></svg>
        </div>
    </div>
    <div style="display: flex; width:100%; height: 30%; justify-content: center;">
        <div>some text</div>
    </div>
    <div style="display: flex;height: 70%; align-items: center;justify-content: space-evenly;border: 1px solid black;">
        <div style="display: flex; height: 100%; align-items: center; justify-content: start;">
            <svg id="pie" width="500" height="450" style="background: transparent;">
            </svg>
        </div>
        <div>
            <svg id="reasons" height="400" width="600" style="background: transparent">
            </svg>
        </div>
    </div>
    <div id="sentimentDisplay" style="display: flex;height: 50%; align-items: center;justify-content: center;">
        <div style="display: flex; flex-direction:column; height: 100%; ">
            <svg id="text1" width="400" style="background: transparent;">
                <div>some text</div>
            </svg>
        </div>
        <div style="display:flex; flex-direction: row;">
            <svg id="sentiment" height="350" width="600" style="background: transparent">
            </svg>
            <div id="sentimentBtn" style="display:flex; flex-direction: column; margin-left: 10px;">
                <button id="sentimentButtonAll">Overall Sentiment</button>
                <button id="sentimentButton1">Sentiment 1</button>
                <button id="sentimentButton2">Sentiment 2</button>
                <button id="sentimentButton3">Sentiment 3</button>
                <svg id="sentimentLgd" height="100" width="320" style="background: transparent"></svg>
                <div id="genderDiv" style="display:none; justify-content: center;">
                    <span id="womanText">Default text</span>
                    <img id="woman" src="./woman.svg" alt="Woman" height="150">
                    <img id="man" src="./man.svg" alt="Man" height="150">
                    <span id="manText">Default text</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const svg = d3.select("#map");
        const width = svg.attr("width");
        const height = svg.attr("height");
        const margin = { top: 20, right: 20, bottom: 20, left: 20 };
        const mapWidth = width - margin.left - margin.right;
        const mapHeight = height - margin.top - margin.bottom;
        const map = svg.append("g").attr("transform", "translate(" + (margin.left + 20) + "," + (margin.top + 5) + ") scale(" + 1 + ")");
        const zoom = d3.zoom()
            .scaleExtent([1, 10])
            .on('zoom', function (event) {
                map.attr('transform', event.transform);
            });

        const pie = d3.select("#pie");
        const pieWidth = pie.attr("width");
        const pieHeight = pie.attr("height");
        const radius = Math.min(pieWidth, pieHeight) / 2.5;
        const pieMargin = { top: 20, right: 20, bottom: 20, left: 20 };
        const pieChart = pie.append("g").attr("transform", `translate(${pieWidth / 2}, ${pieHeight / 2})`);

        const reasons = d3.select("#reasons");
        const reasonsWidth = reasons.attr("width");
        const reasonsHeight = reasons.attr("height");
        const reasonsMapWidth = reasonsWidth - margin.left - margin.right;
        const reasonsMapHeight = reasonsHeight - margin.top - margin.bottom;
        const reasonsMap = reasons.append("g").attr("transform", "translate(" + (margin.left + 10) + "," + (margin.top + 30) + ")");

        const sentiment = d3.select("#sentiment");
        const sentimentWidth = sentiment.attr("width");
        const sentimentHeight = sentiment.attr("height") * 0.8;
        const sentimentMapWidth = sentimentWidth - margin.left - margin.right;
        const sentimentMapHeight = sentimentHeight - margin.top - margin.bottom;
        const sentimentMap = sentiment.append("g").attr("transform", "translate(50,40)");
        var clickedSliceLabel;
        var sentimentDisplay = document.getElementById("sentimentDisplay");
        sentimentDisplay.style.display = "none";

        window.onload = function () {
            var sentimentAll = document.getElementById("sentimentButtonAll");
            var sentiment1 = document.getElementById("sentimentButton1");
            var sentiment2 = document.getElementById("sentimentButton2");
            var sentiment3 = document.getElementById("sentimentButton3");
            const requestData = async function () {
                const oGdata = await d3.csv("./sleeping-pattern-formatted.csv");
                let data = []

                oGdata.forEach(d => {
                    for (let key in d) {
                        if (d[key] === "True") {
                            d[key] = true;
                        } else if (d[key] === "False") {
                            d[key] = false;
                        }
                    }
                    d["Our sex life has improved as a result of sleeping in separate beds"] = d["our sex life has improved as a result of sleeping in separate beds."]
                    d["Sleeping in separate beds helps us to stay together"] = d["sleeping in separate beds helps us to stay together."]
                    d["We sleep better when we sleep in separate beds"] = d["we sleep better when we sleep in separate beds."]

                });

                //////////////////////////////////TOPOJSON MAP/////////////////////////////////////////
                const us = await d3.json("./us-smaller.json");
                var states = topojson.feature(us, us.objects.states);
                var statesMesh = topojson.mesh(us, us.objects.states);
                var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
                var path = d3.geoPath().projection(projection);

                let statePaths = map.selectAll("path.state").data(states.features)
                    .join("path")
                    .attr("class", "state")
                    .attr("d", path);

                map.append("path").datum(statesMesh)
                    .attr("class", "outline")
                    .attr("d", path);

                //////////////////////////////////////////////////////////////////////////////////////

                const sleepFrequencies = oGdata.map(item => item.sleep_freq);
                const uniqueSleepFrequencies = new Set(sleepFrequencies);
                const uniqueSleepFrequenciesArray = [...uniqueSleepFrequencies];
                const totalCount = oGdata.length;
                const count = (data, frequency) => {
                    return data.reduce((count, item) => {
                        if (item.sleep_freq === frequency) {
                            return count + 1;
                        }
                        return count;
                    }, 0);
                };
                const pieValue = [{ label: 'Never', value: count(oGdata, "Never") }, { label: "Once a year or less", value: count(oGdata, "Once a year or less") }, { label: "A few times per month", value: count(oGdata, "A few times per month") }, { label: "Once a month or less", value: count(oGdata, "Once a month or less") }, { label: "A few times per week", value: count(oGdata, "A few times per week") }, { label: "Every night", value: count(oGdata, "Every night") }];
                const colorScale = d3.scaleOrdinal()
                    .domain(['Never', "Once a year or less", "A few times per month", "Once a month or less", "A few times per week", "Every night"])
                    .range(["#958C6F", "#894435", "#97A29D", "#DDD8CC", "#4B5A5B", "#E1886A"]);

                updatePie(pieValue, pieChart, colorScale, radius, -2 * Math.PI / 2, 360, oGdata, reasons, reasonsMapHeight, reasonsMapWidth, sentiment, sentimentMap, sentimentMapHeight, sentimentMapWidth);
                reasonsMapping(oGdata, reasons, reasonsMapHeight, reasonsMapWidth, "", "#434537");

                sentimentAll.addEventListener("click", function () {
                    sentimentChart(oGdata, clickedSliceLabel, 'overview', sentiment, sentimentMap, sentimentMapHeight, sentimentMapWidth);
                });
                sentiment1.addEventListener("click", function () {
                    sentimentChart(oGdata, clickedSliceLabel, 'Our sex life has improved as a result of sleeping in separate beds', sentiment, sentimentMap, sentimentMapHeight, sentimentMapWidth);
                });
                sentiment2.addEventListener("click", function () {
                    sentimentChart(oGdata, clickedSliceLabel, 'Sleeping in separate beds helps us to stay together', sentiment, sentimentMap, sentimentMapHeight, sentimentMapWidth);
                });
                sentiment3.addEventListener("click", function () {
                    sentimentChart(oGdata, clickedSliceLabel, 'We sleep better when we sleep in separate beds', sentiment, sentimentMap, sentimentMapHeight, sentimentMapWidth);
                });

                let groupedData = getDataMapping(oGdata);
                plotCircles(oGdata, groupedData, projection, map, mapHeight, mapWidth);

            }

            requestData();
        };

        function updatePie(pieValue, pieChart, colorScale, radius, startAngle, endAngle, oGdata, reasons, reasonsMapHeight, reasonsMapWidth, sentiment, sentimentMap, sentimentMapHeight, sentimentMapWidth) {
            var clickedSlice = null;
            var arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius);

            var tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('position', 'absolute')
                .style('background-color', 'black')
                .style('padding', '5px')
                .style('border', '1px solid black')
                .style('color', 'white')
                .style('visibility', 'hidden');

            var pie = d3.pie()
                .startAngle(startAngle)
                .endAngle(endAngle)
                .value(function (d) { return d.value; })
                .sort(null);

            var arcs = pieChart.selectAll('g.arc')
                .data(pie(pieValue))
                .enter()
                .append('g')
                .attr('class', 'arc');

            var arcOver = d3.arc()
                .innerRadius(0)
                .outerRadius(radius + 10);

            arcs.append('path')
                .attr('d', arc)
                .attr('fill', function (d, i) { return colorScale(d.data.label); })
                .style('cursor', 'pointer')
                .on('mouseover', function (event, d) {
                    if (clickedSlice !== null) {
                        return;
                    }
                    if (d.data.label === "Never") {
                        return;
                    }
                    if (clickedSlice === null) {
                        reasonsMapping(oGdata, reasons, reasonsMapHeight, reasonsMapWidth, d.data.label, colorScale(d.data.label));
                    }
                    d3.select(this).transition()
                        .duration(500)
                        .attr('d', arcOver)
                        .attr('stroke', '#dee599')
                        .attr('stroke-width', '4');

                    window.requestAnimationFrame(function () {
                        tooltip.style('visibility', 'visible')
                            .text(d.data.label + ': ' + d.data.value)
                            .style('left', (d3.pointer(event)[0] + 10) + 'px')
                            .style('top', (d3.pointer(event)[1] - 10) + 'px');
                    });
                })
                .on('click', function (event, d) {

                    var sentimentDisplay = document.getElementById("sentimentDisplay");
                    if (d.data.label === "Never") {
                        return;
                    }
                    if (clickedSlice === this) {
                        d3.select(clickedSlice).transition()
                            .duration(500)
                            .attr('d', arc)
                            .attr('stroke', 'none');
                        clickedSlice = null;
                        sentimentDisplay.style.display = "none";
                    } else {
                        if (clickedSlice !== null) {
                            sentimentDisplay.style.display = "none";
                            d3.select(clickedSlice).transition()
                                .duration(500)
                                .attr('d', arc)
                                .attr('stroke', 'none');
                        }
                        clickedSlice = this;
                        d3.select(clickedSlice).transition()
                            .duration(500)
                            .attr('d', arcOver)
                            .attr('stroke', '#dee599')
                            .attr('stroke-width', '4');
                        sentimentDisplay.style.display = "flex";
                        sentimentChart(oGdata, d.data.label, 'overview', sentiment, sentimentMap, sentimentMapHeight, sentimentMapWidth);
                        sentimentDisplay.scrollIntoView({ behavior: 'smooth' });
                    }
                    reasonsMapping(oGdata, reasons, reasonsMapHeight, reasonsMapWidth, d.data.label, colorScale(d.data.label));
                    clickedSliceLabel = d.data.label;
                })
                .on('mouseout', function (d) {
                    if (clickedSlice !== null) {
                        return;
                    }
                    if (this !== clickedSlice) {
                        reasonsMapping(oGdata, reasons, reasonsMapHeight, reasonsMapWidth, "", "#434537");
                        d3.select(this).transition()
                            .duration(500)
                            .attr('d', arc)
                            .attr('stroke', 'none');
                        window.requestAnimationFrame(function () {
                            tooltip.style('visibility', 'hidden');
                        });
                    }
                });

            arcs.append('text')
                .attr('transform', function (d) { return 'translate(-80,0)'; })
                .attr('text-anchor', 'middle')
                .style('fill', 'white')
                .text(function (d) { return d.data.label === 'Never' ? d.data.label : ''; });

        }

        function reasonsMapping(oGdata, svg, reasonsMapHeight, reasonsMapWidth, filterVariable, color) {
            if (filterVariable !== "") {
                oGdata = oGdata.filter(d => d.sleep_freq === filterVariable);
            }
            svg.selectAll("*").remove();
            const mappingReasons = {
                "snores": {
                    original: "Snoring",
                    trunc: "Snoring"
                },
                "frequent bathroom trips in the night": {
                    original: "Frequent bathroom trips in the night",
                    trunc: "Frequenting bathroom"
                },
                "sick": {
                    original: "Sick/Ill",
                    trunc: "Sick/Ill"
                },
                "no longer physically intimate": {
                    original: "No longer physically intimate",
                    trunc: "No physical intimacy"
                },
                "different temperature preferences for the room": {
                    original: "Different temperature preferences for the room",
                    trunc: "Temperature preference"
                },
                "argument/fight": {
                    original: "Argument/Fight",
                    trunc: "Argument/Fight"
                },
                "not enough space": {
                    original: "Not enough space to sleep",
                    trunc: "Sleeping space"
                },
                "do not want to share the covers": {
                    original: "Do not want to share the covers",
                    trunc: "Sharing covers"
                },
                "needs to sleep with a child": {
                    original: "One needs to sleep with the child",
                    trunc: "Child needs"
                },
                "night working/very different sleeping times": {
                    original: "Night working/Very different sleeping times",
                    trunc: "Different sleeping times"
                }
            };
            var reasonCounts = countTrueAttributes(oGdata);
            var data = Object.keys(reasonCounts).map(function (key) {
                return {
                    attribute: key,
                    detail: mappingReasons[key],
                    count: reasonCounts[key]
                };
            });

            data.sort((a, b) => b.count - a.count);
            const top5Categories = new Set(data.slice(0, 5).map(d => d.attribute));
            const rootData = {
                name: "Root",
                children: data
            };
            const countsData = data.map(d => d.count);
            const maxCount = d3.max(countsData);
            const minCount = d3.min(countsData);
            const countColorScale = d3.scaleSequential(d3.interpolateRgb("white", color)).domain([minCount, maxCount]);
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("background-color", "#fff")
                .style("padding", "10px")
                .style("border-radius", "5px")
                .style("border", "1px solid #ccc")
                .style("box-shadow", "0 2px 4px rgba(0, 0, 0, 0.1)");


            const treemap = d3.treemap()
                .size([reasonsMapWidth, reasonsMapHeight])
                .padding(1);

            const root = d3.hierarchy(rootData)
                .sum(d => d.count);

            treemap(root);
            svg.selectAll("rect")
                .data(root.leaves())
                .enter().append("rect")
                .attr("x", d => d.x0)
                .attr("y", d => d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("height", d => d.y1 - d.y0)
                .attr("fill", d => countColorScale(d.value))
                .on("mouseover", function (event, d) {
                    tooltip.html(`${d.data.detail.original}<br>Count: ${d.value}`)
                        .style("visibility", "visible");
                })
                .on("mousemove", function (event) {
                    tooltip.style("top", (event.pageY - 10) + "px")
                        .style("left", (event.pageX + 10) + "px");
                })
                .on("mouseout", function () {
                    tooltip.style("visibility", "hidden");
                });


            svg.selectAll("text")
                .data(root.leaves())
                .enter().append("text")
                .filter(d => top5Categories.has(d.data.attribute))
                .attr("x", d => d.x0 + 5)
                .attr("y", d => d.y0 + 20)
                .text(d => `${d.data.detail.trunc}`)
                .attr("font-size", "12px")
                .attr("fill", d => {
                    return d3.lab(countColorScale(d.value)).l < 70 ? "white" : '#82857e';
                });

        }


        function countTrueAttributes(data) {
            var attributes = [
                "different temperature preferences for the room",
                "do not want to share the covers",
                "frequent bathroom trips in the night",
                "needs to sleep with a child",
                "night working/very different sleeping times",
                "no longer physically intimate",
                "not enough space",
                "sick",
                "snores",
                "argument/fight"
            ];

            var counts = {};

            attributes.forEach(function (attribute) {
                counts[attribute] = 0;
            });

            data.forEach(function (obj) {
                attributes.forEach(function (attribute) {
                    if (obj[attribute] === true) {
                        counts[attribute]++;
                    }
                });
            });

            return counts;
        }

        function plotDetailedChart(svg, margin, data, mappingReasons, chartHeight, chartWidth) {
            svg.selectAll("g").remove();
            const detailChart = svg.append("g")
                .attr("transform", "translate(" + margin.left + "," + 40 + ")");
            let counts = {
                bathroom_trip: 0,
                child: 0,
                cover_sharing: 0,
                fight: 0,
                intimacy: 0,
                sick: 0,
                snores: 0,
                space: 0,
                temperature: 0,
                work: 0
            };
            data.forEach(row => {
                for (let key in counts) {

                    if (row[key] === true) {
                        counts[key]++;
                    }
                }
            });
            let countsArray = Object.keys(counts).map(key => ({
                category: key,
                count: counts[key],
                description: mappingReasons[key]
            }));
            countsArray.sort((a, b) => b.count - a.count); // Sort descending by count
            const top5Categories = new Set(countsArray.slice(0, 5).map(d => d.category));
            const rootData = {
                name: "Root",
                children: countsArray
            };
            const countsData = countsArray.map(d => d.count);
            const maxCount = d3.max(countsData);
            const minCount = d3.min(countsData);
            const countColorScale = d3.scaleSequential([minCount, maxCount], d3.interpolateBlues);
            const tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("background-color", "#fff")
                .style("padding", "10px")
                .style("border-radius", "5px")
                .style("border", "1px solid #ccc")
                .style("box-shadow", "0 2px 4px rgba(0, 0, 0, 0.1)");


            const treemap = d3.treemap()
                .size([chartWidth, chartHeight])
                .padding(1);

            const root = d3.hierarchy(rootData)
                .sum(d => d.count);

            treemap(root);

            detailChart.selectAll("rect")
                .data(root.leaves())
                .enter().append("rect")
                .attr("x", d => d.x0)
                .attr("y", d => d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("height", d => d.y1 - d.y0)
                .attr("fill", d => countColorScale(d.value))
                .on("mouseover", function (event, d) {
                    tooltip.html(`${d.data.description.original}<br>Count: ${d.value}`)
                        .style("visibility", "visible");
                })
                .on("mousemove", function (event) {
                    tooltip.style("top", (event.pageY - 10) + "px")
                        .style("left", (event.pageX + 10) + "px");
                })
                .on("mouseout", function () {
                    tooltip.style("visibility", "hidden");
                });

            detailChart.selectAll("text")
                .data(root.leaves())
                .enter().append("text")
                .filter(d => top5Categories.has(d.data.category))
                .attr("x", d => d.x0 + 5)
                .attr("y", d => d.y0 + 20)
                .text(d => `${d.data.description.trunc}`)
                .attr("font-size", "12px")
                .attr("fill", "white");

        }

        function sentimentChart(oGdata, filterVariable, subSection, sentiment, sentimentMap, sentimentMapHeight, sentimentMapWidth) {
            const sentimentDegree = ['Strongly disagree', 'Somewhat disagree', 'Neither agree nor disagree', 'Somewhat agree', 'Strongly agree'];
            const sentimentTopic = [
                "Our sex life has improved as a result of sleeping in separate beds",
                "Sleeping in separate beds helps us to stay together",
                "We sleep better when we sleep in separate beds"
            ];

            if (filterVariable !== "") {
                oGdata = oGdata.filter(d => d.sleep_freq === filterVariable);
            }
            const counts = countSentiments(oGdata, sentimentTopic, sentimentDegree)
            var data = Object.keys(counts).map(function (key) {
                return {
                    attribute: key,
                    count: counts[key]
                };
            });

            if (subSection !== "overview") {
                data = data.filter(d => d.attribute === subSection);
            }
            console.log(data);

            const legendSvg = d3.select("#sentimentLgd");
            const legendWidth = legendSvg.attr("width");
            const legendHeight = legendSvg.attr("height");
            legendSvg.selectAll("*").remove();
            sentimentMap.selectAll("*").remove();
            sentiment.selectAll("text").remove();

            var x = d3.scaleBand()
                .domain(sentimentDegree)
                .range([0, sentimentMapWidth])
                .padding(0.1);

            var xSubgroup = d3.scaleBand()
                .domain(data.map(function (d) { return d.attribute; }))
                .range([0, x.bandwidth()])
                .padding(0.05);

            var y = d3.scaleLinear()
                .domain([0, d3.max(data, function (d) { return d3.max(sentimentDegree, function (degree) { return d.count[degree].total; }); })])
                .range([sentimentMapHeight, 0]);

            sentimentMap.append("g")
                .attr("transform", "translate(0," + sentimentMapHeight + ")")
                .call(d3.axisBottom(x));

            sentimentMap.append("g")
                .call(d3.axisLeft(y));

            var color = d3.scaleOrdinal()
                .domain(sentimentTopic)
                .range(["#966b9d", "#c98686", "#f2b880"]);

            var groups = sentimentMap.selectAll("g.attribute")
                .data(sentimentDegree)
                .enter().append("g")
                .attr("class", "attribute")
                .attr("transform", function (d) { return "translate(" + x(d) + ",0)"; });

            groups.selectAll("rect")
                .data(function (d) {
                    if (subSection === "overview") {
                        return data.map(function (item) {
                            return { attribute: item.attribute, count: item.count[d].total || 0, male: item.count[d].male || 0, female: item.count[d].female || 0 };
                        });
                    } else {
                        return [{ attribute: d, count: data[0].count[d].total || 0, male: data[0].count[d].male || 0, female: data[0].count[d].female || 0 }];  // Return a single-element array if subSection is not "overview"
                    }
                })
                .enter().append("rect")
                .attr("x", function (d) { return xSubgroup(d.attribute); })
                .attr("y", function (d) { return y(d.count); })
                .attr("width", xSubgroup.bandwidth())
                .attr("height", function (d) { return sentimentMapHeight - y(d.count); })
                .attr("fill", function (d) {
                    if (subSection === "overview") {
                        return color(d.attribute);
                    } else {
                        return color(subSection);
                    }
                })
                .on('mouseover', function (event, d) {
                    var femalePerc = (d.female / d.count * 100).toFixed(1);
                    var malePerc = (d.male / d.count * 100).toFixed(1);
                    document.getElementById('womanText').textContent = `${femalePerc}%`;
                    document.getElementById('manText').textContent = `${malePerc}%`;
                    document.getElementById('genderDiv').style.display = 'flex';
                })
                .on('mouseout', function (event, d) {
                    document.getElementById('genderDiv').style.display = 'none';
                });

            sentimentMap.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x))
                .selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .attr("transform", "rotate(-65)");

            sentimentMap.append("text")
                .attr("transform", "translate(" + (sentimentMapWidth / 2) + " ," + (sentimentMapHeight + 40) + ")")
                .style("text-anchor", "middle")
                .text("Sentiment Degree");

            sentimentMap.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - 50)
                .attr("x", 0 - (sentimentHeight / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text("Sentiment Counts");

            sentiment.append("text")
                .attr("x", sentimentMapWidth / 2 + 50)
                .attr("y", 0)
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .style("font-weight", "bold")
                .text(`Sleeping apart... ${filterVariable}`);


            var legend = legendSvg.selectAll('.legend')
                .data(subSection !== 'overview' ? [subSection] : sentimentTopic)
                .enter()
                .append('g')
                .attr('class', 'legend')
                .attr('transform', function (d, i) { return 'translate(' + (-legendWidth + 20) + ',' + ((i * 20) + 10) + ')'; });

            legend.append('rect')
                .attr('x', legendWidth - 18)
                .attr('width', 18)
                .attr('height', 18)
                .style('fill', function (d) { return color(d); });

            legend.append('text')
                .attr('x', legendWidth - 24 + 18 + 10)
                .attr('y', 9)
                .attr('dy', '.35em')
                .style('font-size', '11px')
                .style('text-anchor', 'start')
                .text(function (d) { return d; });

        }

        function countSentiments(data, sentimentTopic, sentimentDegree) {
            var counts = {};

            sentimentTopic.forEach(function (topic) {
                counts[topic] = {};
                sentimentDegree.forEach(function (degree) {
                    counts[topic][degree] = { male: 0, female: 0, total: 0 };
                });
            });

            data.forEach(function (obj) {
                sentimentTopic.forEach(function (topic) {
                    sentimentDegree.forEach(function (degree) {
                        if (obj[topic] === degree) {
                            counts[topic][degree].total++;
                            if (obj["Gender"] === 'Male') {
                                counts[topic][degree].male++;
                            } else if (obj["Gender"] === 'Female') {
                                counts[topic][degree].female++;
                            }
                        }
                    });
                });
            });

            return counts;
        }


        function getDataMapping(data) {

            //derived from ChatGPT
            const locations = [
                { name: "Pacific", coordinates: [-122.4194, 37.7749] }, // Example coordinates for San Francisco
                { name: "South Atlantic", coordinates: [-80.1918, 25.7617] }, // Example coordinates for Miami
                { name: "Middle Atlantic", coordinates: [-74.0060, 40.7128] }, // Example coordinates for New York City
                { name: "East North Central", coordinates: [-87.6298, 41.8781] }, // Example coordinates for Chicago
                { name: "West North Central", coordinates: [-93.2650, 44.9778] }, // Example coordinates for Minneapolis
                { name: "New England", coordinates: [-71.0589, 42.3601] }, // Example coordinates for Boston
                { name: "East South Central", coordinates: [-86.7816, 36.1627] }, // Example coordinates for Nashville
                { name: "West South Central", coordinates: [-95.3698, 29.7604] }, // Example coordinates for Houston
            ];

            const groupedData = {};
            data = data.filter(d => d.sleep_freq !== "Never");
            data.forEach(item => {
                const locationKey = item.location;
                const relationshipYears = item.relationship_years;

                if (!groupedData[locationKey]) {
                    groupedData[locationKey] = {};
                }
                if (!groupedData[locationKey][relationshipYears]) {
                    groupedData[locationKey][relationshipYears] = [];
                }
                groupedData[locationKey][relationshipYears].push(item);
            });

            let aggregatedData = []
            for (let key in groupedData) {
                let chileObj = groupedData[key];
                let childArray = []
                for (let childKey in chileObj) {
                    let child = {
                        years: childKey,
                        items: chileObj[childKey],
                        count: chileObj[childKey].length
                    }
                    childArray.push(child)
                }
                let obj = {
                    location: key,
                    coordinates: locations.find(it => it.name === key).coordinates,
                    items: childArray
                }
                aggregatedData.push(obj)
            }

            return aggregatedData;

        }

        function plotCircles(fulldata, data, projection, map, chartHeight, chartWidth) {
            const flatData = data.flatMap(d =>
                d.items.map(item => ({
                    coordinates: d.coordinates,
                    location: d.location,
                    count: item.count,
                    years: item.years,
                    items: item.items
                }))
            );
            let sizeScale = d3.scaleSqrt()
                .domain([0, d3.max(flatData, d => d["count"])])
                .range([5, 30]);

            const simulation = d3.forceSimulation(flatData)
                .force('x', d3.forceX(d => projection(d.coordinates)[0]).strength(0.2))
                .force('y', d3.forceY(d => projection(d.coordinates)[1]).strength(0.2))
                .force('collide', d3.forceCollide(d => sizeScale(d.count)))
                .on('tick', ticked);

            let zoomedBubble = null;
            function ticked() {
                const circles = map.selectAll('circle')
                    .data(flatData)
                    .join('circle')
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', d => sizeScale(d.count))
                    .style('fill', function (d) {
                        if (d.years === 'Less than 1 year') {
                            return 'url(#image1)';
                        } else if (d.years === '1-5 years') {
                            return 'url(#image2)';
                        } else if (d.years === '6-10 years') {
                            return 'url(#image3)';
                        } else if (d.years === '11-15 years') {
                            return 'url(#image4)';
                        } else if (d.years === '16-20 years') {
                            return 'url(#image5)';
                        } else if (d.years === 'More than 20 years') {
                            return 'url(#image6)';
                        }
                    })
                    .on('click', function (event, d) {
                        const scale = 4;
                        const [x, y] = projection([d.coordinates[0], d.coordinates[1]]);
                        if (zoomedBubble === d) {
                            map.transition().duration(750).call(
                                zoom.transform,
                                d3.zoomIdentity
                            );
                            zoomedBubble = null;
                        } else {
                            map.transition().duration(750).call(
                                zoom.transform,
                                d3.zoomIdentity.translate(mapWidth / 2 - x * scale, mapHeight / 2 - y * scale).scale(scale)
                            );
                            zoomedBubble = d;
                        }
                        })
                    .on('mouseover', function (event, d) {
                        circles.style('opacity', 0.5);
                        circles.filter(d2 => d2.coordinates[0] === d.coordinates[0] && d2.coordinates[1] === d.coordinates[1])
                            .style('opacity', 1);
                        var fullD = fulldata.filter(it => it.location === d.location);
                        const locationData = flatData.filter(d2 => d2.location === d.location);
                        const counts = getCounts(locationData);
                        legend.selectAll('.legend-count')
                            .text(d => (counts[d] / fullD.length) ? `${((counts[d] / fullD.length) * 100).toFixed(1)}%` : "0%");

                    })
                    .on('mouseout', function () {
                        circles.style('opacity', 1);
                        const counts = getCounts(flatData);
                        legend.selectAll('.legend-count')
                            .text(d => (counts[d] / fulldata.length) ? `${((counts[d] / fulldata.length) * 100).toFixed(1)}%` : "0%");
                    });
            }
            const legendSvg = d3.select('#mapLegend');
            const imageUrls = {
                'Less than 1 year': './less_1_years.svg',
                '1-5 years': './1_5_years.svg',
                '6-10 years': './6_10_years.svg',
                '11-15 years': './11_15_years.svg',
                '16-20 years': './16_20_years.svg',
                'More than 20 years': './20_more_years.svg'
            };
            const colorScale = d3.scaleOrdinal()
                .domain(['Less than 1 year', '1-5 years', '6-10 years', '11-15 years', '16-20 years', 'More than 20 years'])
                .range(['#ccffcc', '#99ff99', '#66ff66', '#33cc33', '#009900', '#006600']);

            const legend = legendSvg.selectAll('.legend')
                .data(colorScale.domain())
                .enter().append('g')
                .attr('class', 'legend')
                .attr('transform', function (d, i) { return 'translate(' + i * 150 + ', 120)'; });

            legendSvg.append('text')
                .attr('x', 130)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .text('Legend of relationship years');
            legend.append('image')
                .attr('x', 24)
                .attr('y', -70)
                .attr('width', 70)
                .attr('height', 70)
                .attr('href', d => imageUrls[d]);

            legend.append('text')
                .attr('x', 24)
                .attr('y', 10)
                .attr('dy', '.35em')
                .text(d => d);

            var counts = getCounts(flatData);
            legend.append('text')
                .attr('class', 'legend-count')
                .attr('x', 24)
                .attr('y', 30)
                .attr('dy', '.35em')
                .text(d => `${((counts[d] / fulldata.length) * 100).toFixed(1)}%` || "0%");

            const mapTitle = d3.select('#mapTitle');

            mapTitle.append('text')
                .attr('x', 450)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .style('font-size', '24px')
                .style('font-weight', 'bold')
                .text('Relationship Years and Sleeping apart');

          
        }

        function getCounts(data) {
            const counts = data.reduce((acc, d) => {
                acc[d.years] = (acc[d.years] || 0) + d.count;
                return acc;
            }, {});
            return counts;
        }
    </script>
</body>

</html>